import os.path
import numpy as np
import array
import zlib

from math import ceil, sqrt
from PIL import Image
#### Configuration

save_dir = 'D:\\Gather\\'
undecodedByte = 'FF'

start = '''
            악성코드 분류 딥러닝 모델에 적용할 데이터 수집 프로그램

1. D:\\Gather라는 폴더에 데이터가 수집됩니다.
2. 해당 프로그램은 모든 .exe파일에 대한 이미지 파일을 만드는 것이 목적입니다.
3. 단순히 .exe파일을 실행하지 않고, 읽어서 작업하기 때문에 걱정하지 않아도 됩니다.
4. 프로그램에 문제가 있거나, 소스코드가 궁금하면 010-2002-6205로 연락바랍니다.
5. 실제로 1MB보다 작고 100KB보다 큰 파일의 데이터만 수집하여서 처리합니다.
                                                    made by Choi Hyun Woong
                                                    
먼저 탐색할 드라이브를 입력하세요.
'''

print(start)

end = '''
모든 데이터 수집이 끝났습니다.
D:\\Gather\Images와 list 폴더를 압축하여서 chlrjsdnd2@naver.com으로 보내주시기 바랍니다.
감사합니다.
'''


if not os.path.exists(save_dir):
    os.mkdir(save_dir)
# bytes 파일은 D:\Gather이라는 폴더에 저장된다.

def bytes2png(f, width):
    # bytes를 이미지화 시켜주는 메소드
    file = f

    """
        Construct image name and return if file already exists
    """
    image_name = f.split('.')[0]
    image_buf = image_name.split('\\')
    image_name = image_buf[0] + '\\' + image_buf[1] + '\\' + 'Images' + '\\' + image_buf[2] + '.png'
    # 이미지 저장 경로 설정

    if os.path.isfile(image_name):
        print('Image already exists: {}'.format(image_name))
        return

    b_data = array.array('i')
    for line in open(file, 'r'):
        for byte in line.rstrip().split():
            # 각 라인마다 앞의 8개의 코드는 주소를 뜻하므로, 제외함.
            # 실제 데이터에서 가져올 때에는 주소 개념이 없음.
            if (byte == '??'): byte = undecodedByte
            # byte가 ??인 파트는 따로 처리하는 작업
            # 이 부분이 정확도에 크게 기여하는 곳이므로, 처리할 필요가 있음.
            if (byte.__contains__('\\')):
                continue
                # 간혹 byte 코드에 \\이라고 적힌 부분이 있어서 건너뛰어야 함.
            b_data.append(int(byte, base=16))
            # 16진수 형태로 배열에 부착함

    height = ceil(len(b_data) / width)
    if len(b_data) < (width * height):
        b_data += array.array('i', (0,) * (width * height - len(b_data)))
    image_buffer = np.fromiter(b_data, dtype=np.uint8).reshape((height, width))
    img = Image.fromarray(image_buffer, 'L')
    img.save(image_name)

    txtfile = save_dir + '\\list\\' + 'saveInstance.txt'

    with open(txtfile, mode='a') as f:
        f.write(file.split('\\')[-1] + '\n')

def file_to_hex(fileName):
    try:
        hexList = []
        with open(fileName, mode="rb") as f:
            # 파일 사이즈가 1MB 이하인 파일만 이미지 파일을 생성함.
            if os.stat(fileName).st_size > 1000000 or os.stat(fileName).st_size < 100000:
                return None

            while True:
                buf = f.read(16)
                if not buf:
                    break
                else:
                    hexList.append(buf)

        return hexList  # byte값이 들어있는 리스트로 반환

    except Exception as ex:
        print("[ERROR] : {0}".format(ex))


# 파일 생성
def create_bytes_file(save_dir, filename, data):
    with open(save_dir + filename + ".bytes", mode="wb") as f:
        for i in data:
            f.write(b' '.join(['{:02x}'.format(int(x)).upper().encode() for x in list(i)]) + '\r\n'.encode())

    filepath = save_dir + filename + ".bytes"
    return filepath


def search(dirname):
    try:
        filenames = os.listdir(dirname)
        for filename in filenames:
            if os.stat('D:\\Gather\\Images').st_size > 90000000:
                # 데이터 수집은 80MB까지만 함.
                print(end)
                exit(1)

            full_filename = os.path.join(dirname, filename)
            if os.path.isdir(full_filename):
                search(full_filename)
            else:
                ext = os.path.splitext(full_filename)[-1]
                if ext == '.exe':
                    with open(full_filename, 'rb') as f:
                        bytelist = file_to_hex(full_filename)

                        if bytelist is None:
                            continue
                        filepath = create_bytes_file(save_dir, filename, bytelist)
                        print('filepath : ', dirname + filename)

                        bytes2png(filepath, 256)
                        '''
                        #Train data set
                        lines = f.read().splitlines()
                        first_addr = lines[0].split()[0]
                        last_addr = lines[-1].split()[0]

                        #file_size = int(last_addr, 16) - int(first_addr, 16)
                        file_size = 100000
                        print('{}: {}kB'.format(full_filename, file_size / 1024))
                        if (file_size < 10 * 1024):
                            bytes2png(filepath, 32)
                        elif (file_size < 30 * 1024):
                            bytes2png(filepath, 64)
                        elif (file_size < 60 * 1024):
                            bytes2png(filepath, 128)
                        elif (file_size < 1
                        00 * 1024):
                            bytes2png(filepath, 256)
                        elif (file_size < 200 * 1024):
                            bytes2png(filepath, 384)
                        elif (file_size < 500 * 1024):
                            bytes2png(filepath, 512)
                        elif (file_size < 1000 * 1024):
                            bytes2png(filepath, 768)
                        else:
                            bytes2png(filepath, 1024)
                        '''
    except PermissionError:
        pass

driver = input('Ex. C, D or E = ')
print(driver + ' 드라이브 탐색을 시작합니다.')
search(driver + ':\\')

print(end)
